## 1 .디지털 논리 회로

### **1.1 디지털 컴퓨터**

- 정의
    
    : 이진 시스템을 사용해 계산을 수행하는 디지털 시스템
    
    : 비트 그룹을 사용해 정보 표시, 처리
    
- 하드웨어
    - ‼️ **CPU - 컴퓨터**. 중앙처리 장치. 산술 논리 처리와 데이터 저장, 제어 기능 수행
    - 주변 장치 - 메모리, 저장 장치, 입출력 장치
- 소프트웨어
    - 운영체제 Operationg System
    - 시스템 프로그램
        - OS에 **포함되어** 시스템 운영을 보조
    - 응용 프로그램
- 이진 정보의 표시
    - 0과 1로 표시하는 전압 신호
    - 0 - 0v / 1 - 5v

### **1.2. 논리 게이트**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b1f97dea-c4d4-435b-8524-386503a11889/8b227e22-ff57-4492-8eb5-5d158acbacd6/Untitled.png)

### **1.3. 부울대수**

: 이진 변수와 논리 동작을 취급하는 대수

- 기본 동작 : AND, OR, NOT
- 기본 관계
    - 항등원
        
        <aside>
        💡 x + 0 = x ( x or 0 = x)
        x + 1 = x
        x · 1 = x
        x · 0 = 0
        
        </aside>
        
    - 역원
    - 교환법칙
    - 드모르강의 법칙

## 2. 디지털 부품

### 2.1. 집적 회로

- 정의 및 분류
    - 디지털 게이트를 구성하는 전자 부품을 포함하는 실리콘 반도체 칩
        
        → 이 칩 내부에 게이트들이 연결됨.
        
    - 집적 규모에 따른 분류
        1. SSI : 10개 이하 게이트
        2. MSI: 10~200개 의 게이트. 디코더, 가산기, 레지스터 구현
        3. LSI: 200~1000개의 게이트. 프로세서나 메모리칩 같은 디지털 시스템 형성
        4. VLSI: 초대규모.
- 디지털 논리군
    - TTL: Transister-Transistor Logic 일반 로직 회로 부품
    - ECL: Emitter - Coupled Logic 고속 논리 시스템용 부품(슈퍼💻)
    - MOS: Metal Oxide Semiconductor 고밀도 직접회로용 부품
    - CMOS: Complement Metal Oxide Semiconductor 고밀도 회로, 단순한 제조공정, 저전력 특성

### 2.2 디코더

: N 비트의 이진 정보를 2^N개의 원소 정보로 출력

- NAND 게이트로 만든 디코더
    - 출력 신호 기본값 1, 선택한 신호 0으로 바뀜
        
        출력 신호 1 = 전력 사용 안 함
        
        → 출력이 더 경제적
        
- 인코더
    - 디코더와 반대 동작 수행
    - 2^N개의 입력에 대해 N 이진 코드 출력
    - 한 번에 하나의 입력만이 1의 값을 가질 수 있음
- 주의
    - 입력값& 출력값 높은 비트 순으로 작성!
        
         An .. A2 A1 A0 순
        

### 2.3 멀티플렉서

- 정의
    - N개의 선택 입력에 따라서 2^N개의 출력을 하나의 출력에 선택적으로 연결
    - 여러 개의 입력→여러 개의 기계 → 하나의 기계만 작동
    - 네트워크 스위치(전화, LAN, WAN)의 기본 구조 요소

### 2.4. 레지스터

- 구성
    - N비트 레지스터 : N비트의 이진 정보 저장
    - N개의 플립플롭과 조합회로로 구겅
- 기본 레지스터
    - 클럭펄스 타이밍에 입력값이 레지스터에 저장
    - 레지스터에 저장된 값은 항상 출력에서 참조 가능
        
        값을 갖고 있다 특정 시기에 출력 ㄴㄴ 언제나 참조 가능
        
    - 출력 이름 == 레지스터 이름

### 2.5. 시프트 레지스터

- 정의
    
    : 레지스터에 저장된 이진 정보를 단방향/양방향으로 이동 가능한 레지스터
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b1f97dea-c4d4-435b-8524-386503a11889/71ca9174-9945-4c97-9c5e-1fc613b10a40/Untitled.png)
    
- 병렬 로드를 가지는 양방향 시프트 레지스터
    - 병렬 로드, 양방향 시프트, 병렬 출력 기능
    - General Register

### 2.6. 이진 카운터

: **정해진 순서대로** 상태(=출력값) 변이 수행하는 레지스터

- 병렬 입력을 가진 이진 카운터
    - 카운터 초기값 설정해주는 카운터
    - Load, Clear, Increment 기능

### 2.7. 메모리 장치

- 정의
    - 정보의 입출력 기능을 가지는 저장 요소들의 집합
    - word 단위로 정보를 저장
        - Word : 입출력에서 하나의 단위로 취급되는 비트의 그룹
        - Byte: 워드의 기본 단위
        - MB(10^6byte), GB(10^9byte), PB(10^12byte)
- RAM(random access memory)
    - word의 물리적 위치에 관계 없이 데이터 접근
        
        = 모든 데이터 위치에 대하여 동일한 접근 시간
        
    - N비트의 입력 입력/ 출력
        
        2^k 개의 word 중 하나를 선택
        
        → k 개의 주소라인으로 2^k개의 워드 중 선택
        
- ROM(read only memory)
    - 전원 꺼도 데이터 사라지지 않음
    - 한 번 저장된 데이터를 **읽기**만 가능(RAM 쓰기도 가능)
    - 1 word가 비트이고 M워드를 저장하는 N*M ROM
    - ROM에 저장된 M word 접근할 수 있는 k개의 주소 입력 2^k = M
- ROM 의 종류
    - Mask ROM : 데이터 찍혀 나옴. 바꿀 수도 지울 수도 없음
    - PROM : 프로그램 가능. 한 번만. 그러나 한 번 쓰면 Mask ROM처럼 수정 불가
    - EPROM(Erasable PROM) : UV에 의한 데이터 삭제 및 재프로그래밍 가능.
    - EEPROM
- ROM의 기능을 하는 RAM
    - 전원 꺼져도 데이터 사라지지 않는 RAM
        - Flash-RAM
        - NV-RAM

## 3. 데이터의 표현

### 3. 1. 데이터의 종류

- 컴퓨터 레지스터에서 쓰이는 데이터
    - 산술 연산용 숫자(Numeric)
    - 데이터 처리용영문자(Alpha)
    - 특수 목적용 기호(Special)
- 진수와 진법
    - radix : 진법 기수
    - 2진화 n진수
        - 2진화 8진수 Octal
            
            
            | Octal | BCO | Decimal Equivalent |
            | --- | --- | --- |
            | 0 | 000 | 0 |
            | 1 | 001 | 4 |
            | 7 | 111 | 7 |
            | 10 | 001 000 | 8 |
            | 24 | 010 100 | 20 |
        - 2진화 16진수 Hexadecimal
            
            
            | Hexa | BCH | DE |
            | --- | --- | --- |
            | 0 | 0000 | 0 |
            | 1 | 0001 | 1 |
            | A | 1010 | 10 |
            | C | 1100 | 12 |
            | F2 | 1111 0010 | 242 |
        - 2진화 10진수 Binay Code Decimal
            
            
            | Decimal | BCD |
            | --- | --- |
            | 0 | 0000 |
            | 1 | 0001 |
            | 2 | 0010 |
            | 8 | 1000 |
            | 9 | 1001 |
            | 10 | 0001 0000 |
            | 50 | 0101 0000 |
            | 272 | 0010 0111 0010 |
            | 123 | 0001 0010 0011 |
- 영숫자(Alpha Numeric)의 표시
    - ASCII Code : 7bits(+1 bit - 에러 정정 코드) 2진수
        
        ![당연히 다 외워야? 한다고? 하시네요? ](https://prod-files-secure.s3.us-west-2.amazonaws.com/b1f97dea-c4d4-435b-8524-386503a11889/e4dbc67c-1f88-4a33-87a3-470c97520feb/Untitled.png)
        
        당연히 다 외워야? 한다고? 하시네요? 
        
        열 3비트 + 행 4비트로 표현 : B 100 0010
        
    - EBCDIC Code : IBM에서 쓰는 코드
    - UniCode: 16 bits/ 32bits
        
        → 아스키 코드의 확장판
        
        → **UTF-%%**
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b1f97dea-c4d4-435b-8524-386503a11889/d19ee8ca-09a7-46f3-82d9-f17e0df3d0e9/ed009431-58c0-43df-9dad-ad8c143daacb.png)
        

### 3. 2. 보수

- 보수 : 진법의 기수 r에 대응하는 reverse 값
- r-1의 보수 체계
    - 10진법 → 9 의 보수
        
        12389 ; 99999-12389 = 87610
        
    - 2진법 → 1의 보수
        
        0001111 ; 1111111-0001111=1110000
        
- r 보수 체계
    - 10진법 → 10의 보수
        
        12389; 100000 - 12389 = 87611
        
    - 2진법 → 2의 보수
        
        0001111; 10000000-0001111 =1110001
        
- 부호 없는 숫자의 뺄셈
    1. 보수 더하기
    2. 자릿수 넘어갈 경우 넘어간 부분 무시 
    
    ```jsx
    M = 72532, N = 13250 일 경우 M-N?
    M + N의 보수
    	= 72532 + 86750
    	= 159282
    	(자릿수 초과한 부분 빼기)
    	=> 59282 				
    ```
    

### 3. 3. 고정소수점 표현

- 고정 소수점
    
    : 소수점의 위치를 결정하여 숫자를 표현
    
    : 레지스터 비트에 소수점 위치를 표시
    
- 정수의 표현
    - MSB(most significatn bit)로 부호 표현
        
        양수 msb : 0 
        
        음수 msb : 1
        
    1. 부호 절대값 표현 (-14)
        
        부호 = 1
        
        14 = 0001110
        
        ⇒ 1 0001110
        
    2.  부호화된 1의 보수로 표현( -14)
        
        부호 = 1
        
        14 의보수= 1110001
        
        ⇒ 1 1110001
        
    3. **부호화 된 2의 보수로 표현 (-14)** 🔥
        
        부호 = 1
        
        14의 보수 = 1110010
        
        ⇒ 1 1110010
        
        **⇒ 대부분의  CPU에서 사용하는 방식**
        
- 산술 가산 & 산술 감산
    - 산술 가산 → 절댓값 큰 쪽의 부호 선택
    - 산술 감산 → + (-부호)
- 오버플로우(overflow)의 발생‼️
    
    : N 자리의 두 수를 더 하여 N+1자리가 되었을 경우 정해진 **레지스터 비트 수를 넘어가는** 문제
    
    - 발생
        - 두 수의 부호가 같을 경우에만 생김(당연함. 부호가 다르면 작아지니까..)
    - 처리 방법
        
        :  오버플로우 발생을 미리 확인 
        
        - if C8 ⊕ C7(8비트 기준) = 1 ; OVERFLOW
        - ❓ C8 == 1, C7 ==1 ⇒ 오버 플로우 아닌가요?
            
            ```python
            1 111 1111
            1 111 1111
            
            000 0000 + 1
            ```
            
        
        → 연산 처리하지 않고 에러 처리
        

### 3. 4. 부동 소수점

- 부동소수점 표시방법 (IEEE 754)
    - 가수+지수 표현
    - 가수mantissa : 분수, 정수값 표시
    - 지수component: 십진/이진 소수점 위치를 표시
    
    ⇒ 소수점 위치 옮기기(가수 부분)+지수
    
    예시) 32bit 128 biased 표기 
    
    128 = 0으로 치환
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b1f97dea-c4d4-435b-8524-386503a11889/da04b975-625d-46a7-a4fa-d16d8a51852b/Untitled.png)
    
    - 32 bit - float, single precision
        - 64 bit - double
    - 16 bit - half
- 정규화 Normalization
    - 부동소수점 숫자에서 최상위 비트가 0이 아닌 경우
        
        0 이 있을 경우, 가수의 소수점 위치 이동, 이동한 만큼 exponent의 값 변경
        
    

### 3. 5. 기타 이진 코드

- Grey code
    - 숫자가 다음 숫자로 변할 때 한 비트만 변동
        
        
        | Binary code | Decimal Equivalent |
        | --- | --- |
        | 0000 | 0 |
        | 0001 | 1 |
        | 0011 | 2 |
        | 0010 | 3 |
    - 왜 이런 방식? → 여러 신호 동시 발생 시 에러 낮음. 제어에 많이 사용
- BCD code
    - 10를 4bit 2진수로 표현(10-15 사용 x)
- Excess-3 Code
    - BCD코드 +0011 ⇒암호화
- 기타 코드
    - ASCII : 7bits + parity 1bit
    - EBCDIC : 8bits+paritu 1bit
- ENIGMA : 2차 세계대전 당시 독일에서 쓴 암호 체계

### 3. 6. 에러 검출 코드

- Parity bit
    - 짝수 even parity/ 홀수 odd parity
        
        : 1의 개수가 짝수 개이면 0 아니면 1
        
        : 1의 개수가 홀수 개 이면 0 아니면 1
        
    - 적용
        1. 송신 측: 패리티 발생기
            
            수신 측: 패리티 검사기
            
        2. 수신측 패리티 검사 결과 = 데이터 패리티와 일치 
            
            → 에러 없음 == 0출력
            
            불일치
            
            → 에러 발생 == 1출력 
            

## 4. 레지스터 전송과 마이크로 연산

### 4. 1. 레지스터 전송언어

- 마이크로 연산(Micro-operation)
    - 레지스터에 저장되는 데이터를 가지고 실행되는 기본 동작
    - 하나의 clock 시간 동안 실행되는 기본 동작
    - shift, count, clear, load
- 레지스터 전송 언어
    - 마이크로 연산, 전송을 간단하고 명료하게 표시하기 위하여 사용하는 기호
    - 디지털 컴퓨터의 내부조직을 상세하게 나타내는 수단으로 사용
    - 디지털 시스템의 설계 편의성 제공
- 레지스터 전송 언어 규칙
    - 대문자로 표기
    - 레지스터 가장 왼쪽 데이터 MSB / 가장 오른쪽 LSB
    - 16비트 레지스터
        - 상위 8 -15 : High
        - 하위 0 - 7: Low

### 4. 2. 레지스터 전송

- 레지스터 정보 전송
    - 치환replacement 연산자
        
        치환 하는 쪽 → 치환 받는 쪽
        
    - 제어 조건
        
        if (P = 1) then (R2 ← R1)
        
    - 제어 함수
        
        P : R2 ← R1
        
        P?R2=0:R1=0
        
        (조건?True:False)
        
- 레지스터 전송의 기본 기호
    
    T: R2 ← R1, R1←R2 (exchange)
    

### 4. 3. 버스와 메모리 전송

; 버스 = 데이터 전송을 위한 전송선

- Common Bus 공통버스
    - 레지스터들 사이의 전송 통로
    - 한 번에 하나의 신호만 전송하도록 제어
        
        (당연함. 여러 개가 쓰면 충돌하니까***)***
        
    - ***멀티플렉스***를 사용하여 해당 버스를 사용할 레지스터 선택
    - 레지스터 전송문 예시
        
        BUS ← C, R ← BUS
        
        :EQ R1 ← C
        
- 3-상태 버퍼(3-State Buffer)
    - 멀티플렉서 대신 사용하여 버스 구성 가능
    - 3개의 상태로 동작
        - 논리 0, 논리 1: 정상적인 버퍼
        - 고저항 상태(High-impedance): 출력차단

### 4. 4. 산술 마이크로 연산

: 수치 데이터에 대한 산술 연산

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b1f97dea-c4d4-435b-8524-386503a11889/0278a3dd-016a-4fd2-bd74-dafcd396a812/Untitled.png)

- 이진 가산기
    - 두 비트와 이진 캐리의 산술합을 계산
    - 여러 개의 전가산기를 연결
- 이진 감가산기
    - 보수를 만드는 게이트 사용

### 4. 5. 논리 마이크로 연산

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b1f97dea-c4d4-435b-8524-386503a11889/03c3590e-d0ea-4450-830a-1c58fcfd2c1e/Untitled.png)

NOT, AND , OR, EXCLUSIVE OR 네 가지로 구현 가능

### 4. 6. 시프트 마이크로 연산

- 논리 시프트
    - 직렬 입력으로 0이 전송
        
        R1 ← sh1(R1)
        
        R2 ← shr(R2)
        
- 순환 시프트 Circular Shift(cir, cil)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b1f97dea-c4d4-435b-8524-386503a11889/e628c46b-0cc2-4c71-980f-500d5f74fd3c/Untitled.png)
    
- 산술 시프트
    - 부호 비트 제외하고 시프트
    - 2진수 시프트(
        
        왼쪽 *= 2, 오른쪽 /=2
        

### 4. 7. 산술 논리 시프트 장치

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b1f97dea-c4d4-435b-8524-386503a11889/989cb20d-d889-4660-af85-1aaee48ee896/Untitled.png)